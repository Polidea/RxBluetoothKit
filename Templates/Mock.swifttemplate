import CoreBluetooth
@testable
import RxBluetoothKit
<%_ 
    struct MethodInfo {
        let name: String
        let callName: String
        let formattedName: String
        let lastParamName: String?
    }
    typealias MethodName = String

    class Utils {
        static let classNamesToMock = ["CBCentralManager", "CBPeripheral", "CBDescriptor", "CBService", "CBCharacteristic", "CBL2CAPChannel", "CBPeer"]
        static let protocolNamesToChange = ["CBPeripheralDelegate", "CBCentralManagerDelegate"]

        static func capitalizeFirstLetter(_ text: String) -> String {
            return text.prefix(1).uppercased() + text.dropFirst()
        }

        static func createMethodVariableNames(_ type: Type) -> [MethodName: MethodInfo] {
            var methodVariableNames: [MethodName: MethodInfo] = [:] 
            for method in type.allMethods {
                if let index = methodVariableNames.index(where: { _, value in value.callName == method.callName }) {
                    let methodInfo = methodVariableNames[index].value
                    let methodInfoLastParamName = methodInfo.lastParamName ?? ""
                    methodVariableNames[methodInfo.name] = MethodInfo(
                        name: methodInfo.name,
                        callName: methodInfo.callName,
                        formattedName: "\(methodInfo.callName)With\(capitalizeFirstLetter(methodInfoLastParamName))",
                        lastParamName: methodInfo.lastParamName
                    )
                    let methodLastParamName = method.parameters.last?.name ?? ""
                    methodVariableNames[method.name] = MethodInfo(
                        name: method.name,
                        callName: method.callName,
                        formattedName: "\(method.callName)With\(capitalizeFirstLetter(methodLastParamName))",
                        lastParamName: methodLastParamName
                    )
                } else {
                    methodVariableNames[method.name] = MethodInfo(
                        name: method.name,
                        callName: method.callName,
                        formattedName: method.callName,
                        lastParamName: method.parameters.last?.name
                    )
                }
            }
            return methodVariableNames
        }

        static func changeTypeNameToMock(_ typeName: TypeName) -> String {
            var unwrappedTypeName = typeName.unwrappedTypeName
            if classNamesToMock.contains(unwrappedTypeName) {
                unwrappedTypeName = unwrappedTypeName + "Mock"
            }
            if protocolNamesToChange.contains(unwrappedTypeName) {
                unwrappedTypeName = "_" + unwrappedTypeName
            }
            if let array = typeName.array {
                let elementName = changeTypeNameToMock(array.elementTypeName)
                unwrappedTypeName = "[\(elementName)]"
            }
            var typeName = typeName.isOptional ? "\(unwrappedTypeName)?" : unwrappedTypeName 
            return typeName
        }

        static func printVariable(_ variable: Variable) -> String {
            let typeName = changeTypeNameToMock(variable.typeName)
            let forceUnwrap = variable.isOptional ? "" : "!"
            return "var \(variable.name): \(typeName)\(forceUnwrap)"
        }

        static func printMethodParamTypes(_ method: SourceryRuntime.Method) -> String {
            return method.parameters.reduce("", { "\($0)\(changeTypeNameToMock($1.typeName)), " }).dropLast(2)
        }

        static func printMethodName(_ method: SourceryRuntime.Method) -> String {
            var methodParams = method.parameters.reduce("", { value, parameter in
                var labelPart = ""
                if (value.count == 0 && parameter.argumentLabel == nil) {
                    labelPart = "_ "
                } else if (parameter.argumentLabel != nil && parameter.argumentLabel != parameter.name) {
                    labelPart = "\(parameter.argumentLabel!) "
                }
                var typePart = changeTypeNameToMock(parameter.typeName)
                var defaultPart = parameter.defaultValue != nil ? " = \(parameter.defaultValue!)" : ""
                return "\(value)\(labelPart)\(parameter.name): \(typePart)\(defaultPart), "
            }).dropLast(2)
            return "\(method.callName)(\(methodParams))"
        }
    }
    -%>
    
<%_ for classNameToMock in Utils.classNamesToMock {
        let classToMock = type[classNameToMock]! -%>
class <%= classToMock.name %>Mock: NSObject {
<%_ for variable in classToMock.allVariables { -%>
    <%= Utils.printVariable(variable) %>
<% } -%>

<%_ let mainInit = classToMock.initializers.filter({ !$0.isConvenienceInitializer }).first -%>
    <%= mainInit != nil ? Utils.printMethodName(mainInit!) : "override init()" %> {
    }

<%_ let methodVariableNames = Utils.createMethodVariableNames(classToMock) 
    let filteredMethods = classToMock.allMethods.filter { !$0.isInitializer }
    for method in filteredMethods {
        let formattedName = methodVariableNames[method.name]!.formattedName
        let methodParamsName = "\(formattedName)Params"
        let methodReturnsName = "\(formattedName)Returns"
        let isReturningType = !method.returnTypeName.isVoid 
        let methodReturnDeclaration = isReturningType ? " -> \(Utils.changeTypeNameToMock(method.returnTypeName))" : "" -%>
    var <%= methodParamsName %>: [(<%= Utils.printMethodParamTypes(method) %>)] = []
<% if isReturningType { -%>
    var <%= methodReturnsName %>: [<%= Utils.changeTypeNameToMock(method.returnTypeName) %>] = []
<% } -%>
    func <%= Utils.printMethodName(method) %><%= methodReturnDeclaration %> {
        <%= methodParamsName %>.append((<%= method.parameters.reduce("", { "\($0)\($1.name), " }).dropLast(2) %>))
<% if isReturningType { -%>
        if <%= methodReturnsName %>.isEmpty {
            fatalError("No return value")
        } else {
            return <%= methodReturnsName %>.removeFirst()
        }
<% } -%>
    }

<% } -%>
}

extension <%= classToMock.name %>Mock: Loggable {
    @objc var logDescription: String {
        return "<%= classToMock.name %>Mock"
    }
}

<% } -%>

<%_ for protocolNameToChange in Utils.protocolNamesToChange { 
        let protocolToChange = type[protocolNameToChange]!
        let inheritedTypesString = protocolToChange.inheritedTypes.reduce("", { "\($0)\($1), " }).dropLast(2)
-%>
protocol _<%= protocolToChange.localName %> : <%= inheritedTypesString %> {
<%_ let methodVariableNames = Utils.createMethodVariableNames(protocolToChange) 
    let filteredMethods = protocolToChange.allMethods.filter { !$0.isInitializer }
    for method in filteredMethods {   
        let isReturningType = !method.returnTypeName.isVoid 
        let methodReturnDeclaration = isReturningType ? " -> \(Utils.changeTypeNameToMock(method.returnTypeName))" : ""
-%>     
    func <%= Utils.printMethodName(method) %><%= methodReturnDeclaration %>
<%_ } -%>
}
<%_ } -%>



